diff --git a/xen/arch/x86/efi/efi-boot.h b/xen/arch/x86/efi/efi-boot.h
index 367f6f36b5..fffd1dde50 100644
--- a/xen/arch/x86/efi/efi-boot.h
+++ b/xen/arch/x86/efi/efi-boot.h
@@ -155,9 +155,11 @@ static void __init efi_arch_process_memory_map(EFI_SYSTEM_TABLE *SystemTable,
     for ( e820_raw.nr_map = i = 0; i < map_size; i += desc_size )
     {
         EFI_MEMORY_DESCRIPTOR *desc = map + i;
-        u64 len = desc->NumberOfPages << EFI_PAGE_SHIFT;
+        uint64_t len = efi_memory_descriptor_len(desc);
         u32 type;
 
+        if ( len == 0 )
+            continue;
         switch ( desc->Type )
         {
         default:
diff --git a/xen/common/efi/boot.c b/xen/common/efi/boot.c
index 0fdd73e132..dfdfecfd46 100644
--- a/xen/common/efi/boot.c
+++ b/xen/common/efi/boot.c
@@ -594,15 +594,14 @@ static UINTN __initdata esrt = EFI_INVALID_TABLE_ADDR;
 
 static size_t __init get_esrt_size(const EFI_MEMORY_DESCRIPTOR *desc)
 {
-    size_t available_len, len;
+    UINT64 available_len, len = efi_memory_descriptor_len(desc);
     const UINTN physical_start = desc->PhysicalStart;
     const EFI_SYSTEM_RESOURCE_TABLE *esrt_ptr;
 
-    len = desc->NumberOfPages << EFI_PAGE_SHIFT;
     if ( esrt == EFI_INVALID_TABLE_ADDR )
-        return 0;
+        return 0; /* invalid ESRT */
     if ( physical_start > esrt || esrt - physical_start >= len )
-        return 0;
+        return 0; /* ESRT not in this memory region */
     /*
      * The specification requires EfiBootServicesData, but also accept
      * EfiRuntimeServicesData (for compatibility with buggy firmware)
@@ -1692,7 +1691,7 @@ void __init efi_init_memory(void)
     for ( i = 0; i < efi_memmap_size; i += efi_mdesc_size )
     {
         EFI_MEMORY_DESCRIPTOR *desc = efi_memmap + i;
-        u64 len = desc->NumberOfPages << EFI_PAGE_SHIFT;
+        uint64_t len = efi_memory_descriptor_len(desc);
         unsigned long smfn, emfn;
         unsigned int prot = PAGE_HYPERVISOR_RWX;
         paddr_t mem_base;
@@ -1713,6 +1712,16 @@ void __init efi_init_memory(void)
                     ROUNDUP(desc->PhysicalStart + len, PAGE_SIZE));
         }
 
+        if ( len == 0 )
+        {
+            printk(XENLOG_ERR "BAD EFI MEMORY DESCRIPTOR: "
+                   "PhysicalStart=%016" PRIx64 " NumberOfPages=%016" PRIx64
+                   " type=%" PRIu32 " attr=%016" PRIx64 "\n",
+                   desc->PhysicalStart, desc->NumberOfPages,
+                   desc->Type, desc->Attribute);
+            continue;
+        }
+
         if ( !efi_enabled(EFI_RS) )
             continue;
 
diff --git a/xen/common/efi/efi.h b/xen/common/efi/efi.h
index c02fbb7b69..c86450eb70 100644
--- a/xen/common/efi/efi.h
+++ b/xen/common/efi/efi.h
@@ -51,3 +51,24 @@ void free_ebmalloc_unused_mem(void);
 
 const void *pe_find_section(const void *image, const UINTN image_size,
                             const CHAR16 *section_name, UINTN *size_out);
+
+static inline UINT64
+efi_memory_descriptor_len(const EFI_MEMORY_DESCRIPTOR *desc)
+{
+    uint64_t remaining_space, limit = 1ULL << PADDR_BITS;
+
+    BUILD_BUG_ON(PADDR_BITS >= 64 || PADDR_BITS < 32);
+
+    if ( desc->PhysicalStart & (EFI_PAGE_SIZE - 1) )
+        return 0; /* misaligned start address */
+
+    if ( desc->PhysicalStart >= limit )
+        return 0; /* physical start out of range */
+
+    remaining_space = limit - desc->PhysicalStart;
+
+    if ( desc->NumberOfPages > (remaining_space >> EFI_PAGE_SHIFT) )
+        return 0; /* too many pages */
+
+    return desc->NumberOfPages << EFI_PAGE_SHIFT;
+}
diff --git a/xen/common/efi/runtime.c b/xen/common/efi/runtime.c
index 7e1fce291d..ecde6196d1 100644
--- a/xen/common/efi/runtime.c
+++ b/xen/common/efi/runtime.c
@@ -279,7 +279,7 @@ int efi_get_info(uint32_t idx, union xenpf_efi_info *info)
         for ( i = 0; i < efi_memmap_size; i += efi_mdesc_size )
         {
             EFI_MEMORY_DESCRIPTOR *desc = efi_memmap + i;
-            u64 len = desc->NumberOfPages << EFI_PAGE_SHIFT;
+            uint64_t len = efi_memory_descriptor_len(desc);
 
             if ( info->mem.addr >= desc->PhysicalStart &&
                  info->mem.addr < desc->PhysicalStart + len )
