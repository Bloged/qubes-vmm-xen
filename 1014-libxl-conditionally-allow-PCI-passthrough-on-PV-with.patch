diff --git a/tools/libs/light/libxl_create.c b/tools/libs/light/libxl_create.c
index aa4eb9284a..c04ccd6ad5 100644
--- a/tools/libs/light/libxl_create.c
+++ b/tools/libs/light/libxl_create.c
@@ -1227,12 +1227,18 @@ int libxl__domain_config_setdefault(libxl__gc *gc,
      * This will be insufficient if and when ARM does PCI hotplug.
      */
     bool need_pt = d_config->num_pcidevs || d_config->num_dtdevs;
+    bool iommu_enabled = physinfo.cap_hvm_directio;
+    if (need_pt && !iommu_enabled &&
+            c_info->type == LIBXL_DOMAIN_TYPE_PV &&
+            libxl__is_insecure_pv_passthrough_enabled(gc)) {
+        /* allow insecure PV with IOMMU usage */
+        need_pt = false;
+    }
     if (c_info->passthrough == LIBXL_PASSTHROUGH_DEFAULT) {
         c_info->passthrough = need_pt
             ? LIBXL_PASSTHROUGH_ENABLED : LIBXL_PASSTHROUGH_DISABLED;
     }
 
-    bool iommu_enabled = physinfo.cap_hvm_directio;
     if (c_info->passthrough != LIBXL_PASSTHROUGH_DISABLED && !iommu_enabled) {
         LOGD(ERROR, domid,
              "passthrough not supported on this platform\n");
diff --git a/tools/libs/light/libxl_internal.h b/tools/libs/light/libxl_internal.h
index 39bf133cca..475e365f0e 100644
--- a/tools/libs/light/libxl_internal.h
+++ b/tools/libs/light/libxl_internal.h
@@ -4857,6 +4857,8 @@ static inline const char *libxl__qemu_qmp_path(libxl__gc *gc, int domid)
     return GCSPRINTF("%s/qmp-libxl-%d", libxl__run_dir_path(), domid);
 }
 
+_hidden bool libxl__is_insecure_pv_passthrough_enabled(libxl__gc *gc);
+
 /* Send control commands over xenstore and wait for an Ack. */
 _hidden int libxl__domain_pvcontrol(libxl__egc *egc,
                                     libxl__xswait_state *pvcontrol,
diff --git a/tools/libs/light/libxl_pci.c b/tools/libs/light/libxl_pci.c
index 427b3178ad..59a363add4 100644
--- a/tools/libs/light/libxl_pci.c
+++ b/tools/libs/light/libxl_pci.c
@@ -1553,8 +1553,10 @@ out_no_irq:
         r = xc_assign_device(ctx->xch, domid, pci_encode_bdf(pci), flag);
         if (r < 0 && (hvm || errno != ENOSYS)) {
             LOGED(ERROR, domainid, "xc_assign_device failed");
-            rc = ERROR_FAIL;
-            goto out;
+            if (hvm || errno != EOPNOTSUPP || !libxl__is_insecure_pv_passthrough_enabled(gc)) {
+                rc = ERROR_FAIL;
+                goto out;
+            }
         }
     }
 
@@ -1605,6 +1607,41 @@ static int libxl__device_pci_reset(libxl__gc *gc, unsigned int domain, unsigned
     return -1;
 }
 
+bool libxl__is_insecure_pv_passthrough_enabled(libxl__gc *gc)
+{
+    FILE *f = fopen("/proc/cmdline", "r");
+    char cmdline[4096], *tok;
+    size_t read_s;
+    static int is_enabled = -1;
+
+    if (is_enabled != -1)
+        return is_enabled;
+
+    if (!f) {
+        LOG(WARN, "Failed to open /proc/cmdline: %d", errno);
+        return false;
+    }
+    read_s = fread(cmdline, 1, sizeof(cmdline) - 1, f);
+    if (!feof(f) || ferror(f)) {
+        LOG(WARN, "Failed to read /proc/cmdline: %d", errno);
+        fclose(f);
+        return false;
+    }
+    cmdline[read_s] = 0;
+    fclose(f);
+
+    tok = strtok(cmdline, " \n");
+    while (tok) {
+        if (strcmp(tok, "qubes.enable_insecure_pv_passthrough") == 0) {
+            is_enabled = 1;
+            return true;
+        }
+        tok = strtok(NULL, " \n");
+    }
+    is_enabled = 0;
+    return false;
+}
+
 int libxl__device_pci_setdefault(libxl__gc *gc, uint32_t domid,
                                  libxl_device_pci *pci, bool hotplug)
 {
